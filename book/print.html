<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Suinami book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="topics/00_mod.html"><strong aria-hidden="true">1.</strong> Loose Topics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="topics/01_move_toml.html"><strong aria-hidden="true">1.1.</strong> Upgrades & Deployments</a></li><li class="chapter-item expanded "><a href="topics/02_events.html"><strong aria-hidden="true">1.2.</strong> Events</a></li><li class="chapter-item expanded "><a href="topics/03_vector.html"><strong aria-hidden="true">1.3.</strong> vector[] syntax</a></li><li class="chapter-item expanded "><a href="topics/04_dangling_objects.html"><strong aria-hidden="true">1.4.</strong> Dangling Coins</a></li></ol></li><li class="chapter-item expanded "><a href="patterns/00_mod.html"><strong aria-hidden="true">2.</strong> Advanced Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/01_wit_delegated.html"><strong aria-hidden="true">2.1.</strong> Delegated Witness</a></li><li class="chapter-item expanded "><a href="patterns/02_hot_potato_wrapper.html"><strong aria-hidden="true">2.2.</strong> Hot Potato Wrapper</a></li><li class="chapter-item expanded "><a href="patterns/03_rolling_hot_potato.html"><strong aria-hidden="true">2.3.</strong> Rolling Hot Potato</a></li><li class="chapter-item expanded "><a href="patterns/04_frozen_pub.html"><strong aria-hidden="true">2.4.</strong> Frozen Publisher</a></li><li class="chapter-item expanded "><a href="patterns/05_transferable_dfs.html"><strong aria-hidden="true">2.5.</strong> Transferable Dynamic-Fields</a></li><li class="chapter-item expanded "><a href="patterns/06_map_reduce.html"><strong aria-hidden="true">2.6.</strong> Map-Reduce</a></li></ol></li><li class="chapter-item expanded "><a href="data_structures/00_mod.html"><strong aria-hidden="true">3.</strong> Advanced Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data_structures/01_dynamic_vec.html"><strong aria-hidden="true">3.1.</strong> Dynamic Vectors</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Suinami book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book is devoted to the Sui Move programming language, and it serves as an advanced guide. It targets developers who are looking to deepen their understanding of Sui Move, going beyond the basics to explore complex patterns, optimization techniques, and nuanced features of the language.</p>
<p>If you are new to Sui Move, we highly recommend that you go through the following resources:</p>
<ul>
<li><a href="https://move-book.com/">The Move Book</a></li>
<li><a href="https://examples.sui.io/">Sui Move by Example</a></li>
<li><a href="https://docs.sui.io/concepts/#move">Sui Docs</a></li>
<li><a href="https://docs.sui.io/guides/developer">Sui Developer Guide</a></li>
</ul>
<h3 id="acknowledgements-and-contributions"><a class="header" href="#acknowledgements-and-contributions">Acknowledgements and Contributions</a></h3>
<p>In the creation of this guide for the Sui Move programming language, significant contributions have been made by two exceptional developers, without whom this book would not have been possible in its current depth and scope.</p>
<p>I extend my sincere thanks to <a href="https://github.com/bausano">Porkbrain</a> and <a href="https://github.com/Suficio">Suficio</a> for their collaboration and invaluable contributions in co-developing the advanced patterns in this guide.</p>
<p>In addition, I extend my gratitude to <a href="https://github.com/damirka">Damir</a>, the creator of the <a href="https://move-book.com/">Move Book</a> and <a href="https://examples.sui.io/">Sui by Example</a>, whom we had the pleasure to work with side by side co-developing the Hot Potato Request pattern (i.e rolling hot potato) during the development of the Kiosk standard.</p>
<h3 id="current-development-stage"><a class="header" href="#current-development-stage">Current Development Stage</a></h3>
<p>This book is in its initial phase. Content and examples are subject to significant refinement as we further develop the foundational concepts and incorporate insights from the developer community. Its focus is on providing a thorough and up-to-date guide on advanced Sui Move topics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loose-topics"><a class="header" href="#loose-topics">Loose topics</a></h1>
<p>A list of loose topics:</p>
<ul>
<li><a href="topics/01_move_toml.html">Upgrades &amp; Deployments</a></li>
<li><a href="topics/02_events.html">Events</a></li>
<li><a href="topics/03_vector.html">vector[] syntax</a></li>
<li><a href="topics/04_dangling_objects.html">Dangling Coins</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>Associated readings:</p>
<ul>
<li><a href="https://docs.sui.io/concepts/sui-move-concepts/packages">Sui Docs: Packages</a></li>
<li><a href="https://examples.sui.io/basics/move-toml.html">Sui Move by Example: Move.toml</a></li>
</ul>
<h1 id="deploying-a-contract"><a class="header" href="#deploying-a-contract">Deploying a contract</a></h1>
<p>A couple of important things to keep in mind when deploying contracts.</p>
<p>To deploy a contract you need to keep its address as <code>0x</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;Request&quot;
version = &quot;1.6.0&quot;

[dependencies.Sui]
git = &quot;https://github.com/MystenLabs/sui.git&quot;
subdir = &quot;crates/sui-framework/packages/sui-framework&quot;
# mainnet-1.15.1
rev = &quot;08119f95e9ccdc926eae3fff8c95e50678f56aed&quot;

[dependencies.Permissions]
local = &quot;./../permissions&quot;

[addresses]
ob_request = &quot;0x&quot;
</code></pre>
<p>Once we have deployed the contract successfully we need to insert the package ID into the move.toml to link the codebase to the on-chain smart contract. When we deploy the contract a package ID will be generated, in our case is <code>0xe2c7a6843cb13d9549a9d2dc1c266b572ead0b4b9f090e7c3c46de2714102b43</code>. We therefore add this as the address:</p>
<pre><code class="language-toml">[package]
name = &quot;Request&quot;
version = &quot;1.6.0&quot;

[dependencies.Sui]
git = &quot;https://github.com/MystenLabs/sui.git&quot;
subdir = &quot;crates/sui-framework/packages/sui-framework&quot;
# mainnet-1.15.1
rev = &quot;08119f95e9ccdc926eae3fff8c95e50678f56aed&quot;

[dependencies.Permissions]
local = &quot;./../permissions&quot;

[addresses]
ob_request = &quot;0xe2c7a6843cb13d9549a9d2dc1c266b572ead0b4b9f090e7c3c46de2714102b43&quot;
</code></pre>
<h1 id="upgrading-a-contract"><a class="header" href="#upgrading-a-contract">Upgrading a contract</a></h1>
<p>To upgrade the contract we have to reset the address to <code>0x</code> and invoke the call to upgrade the contract via the <a href="https://docs.sui.io/references/cli">sui-cli</a>. A new package will be generated. In our case the new version package is <code>0xadf32ebafc587cc86e1e56e59f7b17c7e8cbeb3315193be63c6f73157d4e88b9</code>. We now relink the codebase by adding the new package ID in the <code>published-at</code> field and add back the original package ID in the addresses:</p>
<pre><code class="language-toml">[package]
name = &quot;Request&quot;
version = &quot;1.6.0&quot;
published-at = &quot;0xadf32ebafc587cc86e1e56e59f7b17c7e8cbeb3315193be63c6f73157d4e88b9&quot;

[dependencies.Sui]
git = &quot;https://github.com/MystenLabs/sui.git&quot;
subdir = &quot;crates/sui-framework/packages/sui-framework&quot;
# mainnet-1.15.1
rev = &quot;08119f95e9ccdc926eae3fff8c95e50678f56aed&quot;

[dependencies.Permissions]
local = &quot;./../permissions&quot;

[addresses]
ob_request = &quot;0xe2c7a6843cb13d9549a9d2dc1c266b572ead0b4b9f090e7c3c46de2714102b43&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Associated readings:</p>
<ul>
<li><a href="https://docs.sui.io/guides/developer/sui-101/using-events">Sui Docs: Using Events</a></li>
<li><a href="https://examples.sui.io/basics/events.html">Sui Move by Example: Events</a></li>
<li><a href="https://github.com/nmboavida/suinami-book/blob/main/examples/sources/events.move">Examples: Event Wrapper</a></li>
</ul>
<h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>The available sources cover the majority that there is to be known about on-chain events. An important note that we would like to cover is how events interact with package versioning. The rule that events follow is that events will be emitted from their package of origin. This means that if you use an off-chain event listener you will subscribe to the events of a smart contract by referring to its original package ID.</p>
<p>There is a caveat nonetheless. What happens when you introduce a new event in a newer version? These events will be generated by their original package ID, however this time they do not correspond to the original smart contract package ID, but the version in which this got introduced. This can complicate matters and therefore in general we recomment developers to keep track of the event sources and describe them in their documentation.</p>
<p>To ensure that ALL events including newly introduced events in later package versions, you should export a wrapper event struct in your original package:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Event&lt;T: copy + drop&gt; has copy, drop {
    event: T,
}
<span class="boring">}</span></code></pre></pre>
<p>This ensures that any subsequently added evenet will inherit the original package ID as its outer type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>event::emit(Event { event: SomeEvent {}});
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector-syntax"><a class="header" href="#vector-syntax">vector[] syntax</a></h1>
<p>Vectors are a pretty standard structure in Move. To initiate a vector you would normally write:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_vec = vector::empty();
vector::append(&amp;mut my_vec, 1);
vector::append(&amp;mut my_vec, 2);
vector::append(&amp;mut my_vec, 3);
<span class="boring">}</span></code></pre></pre>
<p>To make it more ergonomic, you can use the <code>vector[]</code> syntax as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_vec = vector[1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Associated readings:</p>
<ul>
<li><a href="https://docs.sui.io/concepts/dynamic-fields">Sui Docs: Dynamic Fields</a></li>
<li><a href="https://github.com/Origin-Byte/nft-protocol/blob/main/contracts/utils/sources/dynamic_vec.move">OriginByte: Dynamic Vector</a></li>
</ul>
<h1 id="dangling-coins"><a class="header" href="#dangling-coins">Dangling Coins</a></h1>
<p>In the Sui blockchain, an object with dynamic fields can be deleted, even if those fields are not deleted with it. Once the object is deleted, all its dynamic fields become unreachable for future transactions, in other words they become dangling objects. This is the case no matter if these field values are equipped with the 'drop' ability or not.</p>
<p>This is especially problematic if the object concerned has some real-world value such as <code>Coin&lt;T&gt;</code>. take the following example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module examples::dangling_coin {
    use sui::coin;
    use sui::sui::SUI;
    use sui::dynamic_field as df;
    use sui::object::{Self, UID};
    use sui::test_scenario::{Self, ctx};

    const SOME_ADDRESS: address = @0x1;
    const USER: address = @0x2;

    struct SomeObject has key, store {
        id: UID,
    }

    fun burn_obj(obj: SomeObject) {
        let SomeObject { id } = obj;
        object::delete(id);
    }

    #[test]
    fun dangling_coin() {
        let scenario = test_scenario::begin(SOME_ADDRESS);
        let some_obj = SomeObject {
            id: object::new(ctx(&amp;mut scenario)),
        };

        let sui_coins = coin::mint_for_testing&lt;SUI&gt;(10_000, ctx(&amp;mut scenario));

        df::add(&amp;mut some_obj.id, 1, sui_coins);

        burn_obj(some_obj);

        test_scenario::end(scenario);
    }

}
<span class="boring">}</span></code></pre></pre>
<p>This code does in fact compile and the test passes. In other words, in this test case, 10_000 SUI coins have become unreachable. We recommend developers to always be extra cautious when burning object that have dynamic fields such that validations are put in place to prevent them from being burned in case valueable assets are held dynamically in it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-patterns"><a class="header" href="#advanced-patterns">Advanced Patterns</a></h1>
<p>A list of advanced patterns in Sui Move:</p>
<ul>
<li><a href="patterns/01_wit_delegated.html">Delegated Witness</a></li>
<li><a href="patterns/02_hot_potato_wrapper.html">Hot Potato Wrapper</a></li>
<li><a href="patterns/03_rolling_hot_potato.html">Rolling Hot Potato</a></li>
<li><a href="patterns/04_frozen_pub.html">Frozen Publisher</a></li>
<li><a href="patterns/05_transferable_dfs.html">Transferable Dynamic-Fields</a></li>
<li><a href="patterns/06_map_reduce.html">Map-Reduce</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>Associated readings:</p>
<ul>
<li><a href="https://examples.sui.io/patterns/witness.html">Sui Move by Example: Witness</a></li>
<li><a href="https://github.com/Origin-Byte/nft-protocol/blob/main/contracts/permissions/sources/permissions/witness.move">OriginByte: Delegated Witness</a></li>
<li><a href="https://github.com/nmboavida/suinami-book/blob/main/examples/sources/delegated_wit.move">Examples: Delegated Witness</a></li>
</ul>
<h1 id="delegated-witness"><a class="header" href="#delegated-witness">Delegated Witness</a></h1>
<blockquote>
<p>The witness pattern is a fundamental pattern in Sui Move for building a permissioning system around the types of your smart contract. A certain contract might declare an <code>Object&lt;T&gt;</code> which uses the witness pattern to allow for the contract that creates <code>T</code> to maintain exclusivity when generating <code>Object&lt;T&gt;</code>.</p>
</blockquote>
<p>Let's say that in contract A declares the following type and constructor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module examples::contract_a {
    use sui::object::{Self, UID};
    use sui::tx_context::TxContext;

    struct ObjectA&lt;phantom T: drop&gt; has key, store {
        id: UID
    }

    public fun new&lt;T: drop&gt;(
        _witness: T, ctx: &amp;mut TxContext
    ): ObjectA&lt;T&gt; {
        ObjectA { id: object::new(ctx) }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Contract X can then declare a Witness type such that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module examples::contract_x {
    use sui::transfer;
    use sui::tx_context::{Self, TxContext};

    use examples::contract_a;

    // Witness type
    struct TypeX has drop {}

    fun init(ctx: &amp;mut TxContext) {
        transfer::public_transfer(
            contract_a::new(TypeX {}, ctx),
            tx_context::sender(ctx)
        )
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Given that only <code>contract_b</code> can instantiate <code>TypeB</code>, we guarante that <code>Object&lt;TypeB&gt;</code> can only be created by <code>contract_b</code> even though the generic object <code>Object</code> is declared in <code>contract_a</code>.</p>
<h2 id="using-the-witness-pattern-for-multiple-types"><a class="header" href="#using-the-witness-pattern-for-multiple-types">Using the <code>Witness</code> pattern for multiple types</a></h2>
<p>The example above shows the power of the <code>Witness</code> pattern. However, this type of permissioning works when <code>T</code> has <code>drop</code>. What if we have a case in which <code>SomeObject&lt;T: key + store&gt;</code>? In this case, we can use a slightly different version of the witness pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module examples::contract_b {
    use sui::object::{Self, UID};
    use sui::tx_context::TxContext;
    use ob_utils::utils;

    struct ObjectB&lt;T: key + store&gt; has key, store {
        id: UID,
        obj: T
    }

    public fun new&lt;W: drop, T: key + store&gt;(
        _witness: W, obj: T, ctx: &amp;mut TxContext
    ): ObjectB&lt;T&gt; {
        // Asserts that `W` and `T` come from the same
        // module, via type reflection
        utils::assert_same_module&lt;W, T&gt;();

        ObjectB { id: object::new(ctx), obj }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now this allow us to use the our witness object to insert any object from our module with <code>key</code> and <code>store</code> in <code>Object&lt;T&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module examples::contract_y {
    use sui::transfer;
    use sui::tx_context::{Self, TxContext};
    use sui::object::{Self, UID};

    use examples::contract_b;

    // Witness type
    struct Witness has drop {}

    struct TypeY has key, store {
        id: UID
    }

    fun init(ctx: &amp;mut TxContext) {
        transfer::public_transfer(
            contract_b::new(Witness {}, TypeY { id: object::new(ctx) }, ctx),
            tx_context::sender(ctx)
        )
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Note that this pattern functions well for objects that wrap other objects with <code>key</code> and <code>store</code>. Under the hood we are using an assertion exported by the OriginByte utils module implemented as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Assert that two types are exported by the same module.
public fun assert_same_module&lt;T1, T2&gt;() {
    let (package_a, module_a, _) = get_package_module_type&lt;T1&gt;();
    let (package_b, module_b, _) = get_package_module_type&lt;T2&gt;();

    assert!(package_a == package_b, EInvalidWitnessPackage);
    assert!(module_a == module_b, EInvalidWitnessModule);
}

public fun get_package_module_type&lt;T&gt;(): (String, String, String) {
    let t = string::utf8(ascii::into_bytes(
        type_name::into_string(type_name::get&lt;T&gt;())
    ));

    get_package_module_type_raw(t)
}

public fun get_package_module_type_raw(t: String): (String, String, String) {
    let delimiter = string::utf8(b&quot;::&quot;);

    // TBD: this can probably be hard-coded as all hex addrs are 64 bytes
    let package_delimiter_index = string::index_of(&amp;t, &amp;delimiter);
    let package_addr = sub_string(&amp;t, 0, string::index_of(&amp;t, &amp;delimiter));

    let tail = sub_string(&amp;t, package_delimiter_index + 2, string::length(&amp;t));

    let module_delimiter_index = string::index_of(&amp;tail, &amp;delimiter);
    let module_name = sub_string(&amp;tail, 0, module_delimiter_index);

    let type_name = sub_string(&amp;tail, module_delimiter_index + 2, string::length(&amp;tail));

    (package_addr, module_name, type_name)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="delegated-witness-1"><a class="header" href="#delegated-witness-1">Delegated Witness</a></h2>
<p>The delegated witness functions as an hybrid between the <code>Witness</code> and the <code>Publisher</code> pattern with the addition that it provides a <code>WitnessGenerator</code> which allows for the witness creation to be delegated to other smart contracts/objects defined in modules other than the creator of <code>T</code>.</p>
<p>In a nutshell, the differences between a Delegated-Witness and a typical Witness are:</p>
<ul>
<li>Delegated-Witness has copy and it can therefore be easily propagated accross a stack of function calls;</li>
<li>Delegated-Witness is typed, and this in conjunction with the copy ability allows for the reduction of type-reflected assertions that are required to be perfomed accross the call stack</li>
<li>A Delegated-Witness can be created by <code>Witness {}</code>, so like the witness its access can be designed by the smart contract that defines <code>T</code>;</li>
<li>It can also be created directly through the Publisher object;</li>
<li>It can be generated by a generator object <code>WitnessGenerator&lt;T&gt;</code> which has store ability, therefore allowing for witness-creation process to be more flexibly delegated.</li>
</ul>
<p>Note: This pattern enhaces the programability around object permissions but it should be handled with care, and developers ought to fully understand its safety implications. In addition, one can use this pattern without the <code>WitnessGenerator&lt;T&gt;</code>, rather this generator is in of itself a pattern that is built on top of the Delegated Witness.</p>
<p>From the OriginByte permissions package we have:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Delegated witness of a generic type. The type `T` can either be
/// the One-Time Witness of a collection or the type of an object itself.
struct Witness&lt;phantom T&gt; has copy, drop {}

/// Delegate a delegated witness from arbitrary witness type
public fun from_witness&lt;T, W: drop&gt;(_witness: W): Witness&lt;T&gt; {
    utils::assert_same_module_as_witness&lt;T, W&gt;();
    Witness {}
}

/// Creates a delegated witness from a package publisher.
/// Useful for contracts which don't support our protocol the easy way,
/// but use the standard of publisher.
public fun from_publisher&lt;T&gt;(publisher: &amp;Publisher): Witness&lt;T&gt; {
    utils::assert_publisher&lt;T&gt;(publisher);
    Witness {}
}
<span class="boring">}</span></code></pre></pre>
<p>We can now have two contract that do:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module examples::contract_c {
    use sui::object::{Self, UID};
    use sui::tx_context::TxContext;
    use ob_permissions::witness::{Witness as DelegatedWit};

    struct ObjectC&lt;T: key + store&gt; has key, store {
        id: UID,
        obj: T
    }

    public fun new&lt;T: key + store&gt;(
        _delegated_wit: DelegatedWit&lt;T&gt;, obj: T, ctx: &amp;mut TxContext
    ): ObjectC&lt;T&gt; {
        ObjectC { id: object::new(ctx), obj }
    }
}

module examples::contract_d {
    use sui::object::{Self, UID};
    use sui::tx_context::TxContext;
    use ob_permissions::witness::{Witness as DelegatedWit};

    use examples::contract_c::{Self, ObjectC};

    struct ObjectD&lt;T: key + store&gt; has key, store {
        id: UID,
        obj_c: ObjectC&lt;T&gt;
    }

    public fun new&lt;T: key + store&gt;(
        delegated_wit: DelegatedWit&lt;T&gt;, obj_c: T, ctx: &amp;mut TxContext
    ): ObjectD&lt;T&gt; {
        ObjectD {
            id: object::new(ctx),
            obj_c: contract_c::new(delegated_wit, obj_c, ctx)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In other words the authorization can be propagated throughout the call stack.</p>
<h2 id="witness-generator"><a class="header" href="#witness-generator">Witness Generator</a></h2>
<p>TODO!</p>
<div style="break-before: page; page-break-before: always;"></div><p>Associated readings:</p>
<ul>
<li><a href="https://docs.sui.io/concepts/transactions/prog-txn-blocks">Sui Docs: Programmable Transactions</a></li>
<li><a href="https://examples.sui.io/patterns/hot-potato.html">Sui Move by Example: Hot Potato</a></li>
<li><a href="https://github.com/nmboavida/suinami-book/blob/main/examples/sources/hot_potato_wrapper.move">Examples: Hot Potato Wrapper</a></li>
</ul>
<h1 id="hot-potato-wrapper"><a class="header" href="#hot-potato-wrapper">Hot Potato Wrapper</a></h1>
<p>In Sui, a hot potato is an object without abilities, and that therefore must be consumed in the same transactional batch that is has been created in (since it does not have <code>drop</code> ability it must be burned by the contract that declared its type). This is a very useful pattern because it allows developers to enforce that a certain chain of programmable calls ought to be executed, otherwise leading to the transaction batch failing. This pattern became extremely powerful especially since the introduction of Programmable Transactions.</p>
<p>Hot Potatoes are composable, which means that you can wrap them in other Hot Potatoes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>module examples::hot_potato_wrapper {
    use sui::test_scenario;

    struct HotPotato {}

    struct HotPotatoWrapper {
        potato: HotPotato
    }

    fun delete_potato_wrapper(wrapper: HotPotatoWrapper): HotPotato {
        let HotPotatoWrapper {
            potato,
        } = wrapper;

        potato
    }

    fun delete_potato(potato: HotPotato) {
        let HotPotato {} = potato;
    }

    #[test]
    fun try_wrap_potato() {
        let scenario = test_scenario::begin(@0x0);

        let potato_wrapper = HotPotatoWrapper {
            potato: HotPotato {},
        };

        let potato = delete_potato_wrapper(potato_wrapper);

        delete_potato(potato);

        test_scenario::end(scenario);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Associated readings:</p>
<ul>
<li><a href="https://docs.sui.io/concepts/transactions/prog-txn-blocks">Sui Docs: Programmable Transactions</a></li>
<li><a href="https://examples.sui.io/patterns/hot-potato.html">Sui Move by Example: Hot Potato</a></li>
<li><a href="https://github.com/Origin-Byte/nft-protocol/blob/main/contracts/request/sources/request/request.move">OriginByte: Request Hot Potato</a></li>
<li><a href="https://github.com/nmboavida/suinami-book/blob/main/examples/sources/rolling_hot_potato.move">Examples: Rolling Hot Potato</a></li>
</ul>
<h1 id="rolling-hot-potato"><a class="header" href="#rolling-hot-potato">Rolling Hot Potato</a></h1>
<p>As stated in the previous chapter, in Sui, a hot potato is an object without abilities, and that therefore must be consumed in the same transactional batch that is has been created in (since it does not have drop ability it must be burned by the contract that declared its type). This is a very useful pattern because it allows developers to enforce that a certain chain of programmable calls ought to be executed, otherwise leading to the transaction batch failing. This pattern became extremely powerful especially since the introduction of Programmable Transactions.</p>
<p>Following the introduction of Programmable Transactions the Rolling Hot Potato pattern as been introduced by Mysten Labs and Originbyte in collaboration during the development of the Kiosk.</p>
<p>Below follows a generic implementation which seves as a way of validating that a set of actions has been taken. Since hot potatoes need to be consumed at the end of the Programmable Transactions Batch, smart contract developers can force clients to perform a particular set of actions given a genesis action.</p>
<p>The module can be found in OriginByte <a href="https://github.com/Origin-Byte/nft-protocol/tree/main/contracts/request">Request</a> package and consists of three core objects:</p>
<ul>
<li><code>Policy&lt;P&gt;</code> is the object that registers the rules enforced for the policy <code>P</code>, as well configuration state associated to each rule;</li>
<li><code>PolicyCap</code> is a capability object that gives managerial access for a given policy object</li>
<li><code>RequestBody&lt;P&gt;</code> is the inner body of a hot-potato object that contains the receipts collected by performing the enforced actions, as well as the metata associated to them as well as the policy resolution logic. <code>RequestBody&lt;P&gt;</code> is meant to be wrapped by a hot-potato object, but is itself a hot-potato.</li>
</ul>
<p>Any developer can implement their logic on top of these generic objects in order to build their own chain of required actions. An example goes as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module examples::request_policy {
    use sui::object::{Self, ID};
    use sui::tx_context::TxContext;
    use ob_request::request::{Self, RequestBody, Policy, PolicyCap};

    // === Errors ===

    const EPolicyMismatch: u64 = 1;

    // === Structs ===

    /// Witness for initating a policy
    struct AUTH_REQ has drop {}

    /// Rolling Hot Potato
    struct AuthRequest {
        policy_id: ID,

        // .. other fields ..

        inner: RequestBody&lt;AUTH_REQ&gt;
    }

    /// Construct a new `Request` hot potato which requires an
    /// approving action from the policy creator to be destroyed / resolved.
    public fun new(
        policy: &amp;Policy&lt;AUTH_REQ&gt;, ctx: &amp;mut TxContext,
    ): AuthRequest {
        AuthRequest {
            policy_id: object::id(policy),
            inner: request::new(ctx),
        }
    }

    public fun init_policy(ctx: &amp;mut TxContext): (Policy&lt;AUTH_REQ&gt;, PolicyCap) {
        // Policy creation is gated using the Witness Pattern
        request::new_policy(AUTH_REQ {}, ctx)
    }

    /// Adds a `Receipt` to the `Request`, unblocking the request and
    /// confirming that the policy requirements are satisfied.
    public fun add_receipt&lt;Rule: drop&gt;(self: &amp;mut AuthRequest, rule: Rule) {
        request::add_receipt(&amp;mut self.inner, &amp;rule);
    }

    // No need for witness protection as this is admin only endpoint,
    // protected by the `PolicyCap`. The type `Rule` is a type marker for
    // a given rule defined in an external contract
    public entry fun enforce&lt;Rule: drop&gt;(
        policy: &amp;mut Policy&lt;AUTH_REQ&gt;, cap: &amp;PolicyCap,
    ) {
        request::enforce_rule_no_state&lt;AUTH_REQ, Rule&gt;(policy, cap);
    }

    public fun confirm(self: AuthRequest, policy: &amp;Policy&lt;AUTH_REQ&gt;) {
        let AuthRequest {
            policy_id,
            inner,
        } = self;
        assert!(policy_id == object::id(policy), EPolicyMismatch);
        request::confirm(inner, policy);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We can now build a pipeline of required actions such that:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...

// User performs all required actions
policy_actions::action_a(&amp;mut request);
policy_actions::action_b(&amp;mut request);
policy_actions::action_c(&amp;mut request);

// The request hot potato can now be safely destroyed
request_policy::confirm(request, &amp;policy);
<span class="boring">}</span></code></pre></pre>
<p>In other words, if the caller does not perform action A, B and C, the transaction will fail.</p>
<p>In order for these three actions to be required by the policy, their respective contracts need to export a function which has to be called by the owner of the policy:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...

// Admin enforces rules A, B and C
request_policy::enforce&lt;RuleA&gt;(&amp;mut policy, &amp;cap);
request_policy::enforce&lt;RuleB&gt;(&amp;mut policy, &amp;cap);
request_policy::enforce&lt;RuleC&gt;(&amp;mut policy, &amp;cap);
<span class="boring">}</span></code></pre></pre>
<p>Actions can then be added from other contracts or modules:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module examples::policy_actions {
    use sui::tx_context::TxContext;
    use ob_request::request::Policy;

    use examples::request_policy::{Self, AuthRequest, AUTH_REQ};

    struct RuleA has drop {} // Witness and Type marker for Rule A
    struct RuleB has drop {} // Witness and Type marker for Rule B
    struct RuleC has drop {} // Witness and Type marker for Rule C

    public fun genesis_action(
        policy: &amp;Policy&lt;AUTH_REQ&gt;, ctx: &amp;mut TxContext,
    ): AuthRequest {
        request_policy::new(policy, ctx)
    }

    /// Performs a given action A
    public fun action_a(
        req: &amp;mut AuthRequest,
    ) {
        // .. Performe some action ..

        request_policy::add_receipt(req, RuleA {})
    }
    
    /// Performs a given action B
    public fun action_b(
        req: &amp;mut AuthRequest,
    ) {
        // .. Performe some action ..

        request_policy::add_receipt(req, RuleB {})
    }
    
    /// Performs a given action C
    public fun action_c(
        req: &amp;mut AuthRequest,
    ) {
        // .. Performe some action ..

        request_policy::add_receipt(req, RuleC {})
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Associated readings:</p>
<ul>
<li><a href="https://examples.sui.io/patterns/hot-potato.html">Sui Move by Example: Hot Potato</a></li>
<li><a href="https://examples.sui.io/basics/publisher.html">Move by Example: Publisher</a></li>
<li><a href="https://github.com/Origin-Byte/nft-protocol/blob/main/contracts/permissions/sources/permissions/frozen_publisher.move">OriginByte: Frozen Publisher</a></li>
<li><a href="https://github.com/nmboavida/suinami-book/blob/main/examples/sources/frozen_pub.move">Examples: Frozen Publisher</a></li>
</ul>
<h1 id="frozen-publisher"><a class="header" href="#frozen-publisher">Frozen Publisher</a></h1>
<blockquote>
<p>The Publisher Object in Sui confers authority to the publisher, in other words, to the one deploying the contract on-chain. With it developers can create priviledged entrypoints of which only the holder of the <code>Publisher</code> object can call. The <code>Publisher</code> along with its <code>package</code> module is essentially used to verify if a type <code>T</code> is part of a module or package associated with the <code>Publisher</code> object.</p>
</blockquote>
<p>The <code>Publisher</code> pattern is a powerful permissioning pattern in Sui Move, and its use case can be seen in the Sui Display standard.</p>
<blockquote>
<p>The Sui Object Display standard functions as a template engine, facilitating the management of how an object is represented off-chain through on-chain mechanisms. This standard allows for the integration of an object's data into a template string, offering flexibility in the selection of fields to include.</p>
</blockquote>
<p>One challenge that arises with it however is when using wrapper types <code>Wrapper&lt;T&gt;</code>, in that it not possible for a type <code>T</code> to define its own display if its wrapped by <code>Wrapper&lt;T&gt;</code>. The is because the outer type take precedence over the inner type.</p>
<p>We introduce the idea of a <code>FrozenPublisher</code> which can be used by the wrapper module to allow for the publisher of <code>T</code> to define its own display of <code>Wrapper&lt;T&gt;</code>. In other words it allows the publisher of the type <code>Wrapper</code> to delegate to the type <code>T</code>. This way, the inner type <code>T</code> has the necessary degrees of freedom to define its display.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module ob_permissions::frozen_publisher {
    // ...

    struct FrozenPublisher has key {
        id: UID,
        inner: Publisher,
    }

    // ...

    public fun freeze_from_otw&lt;OTW: drop&gt;(otw: OTW, ctx: &amp;mut TxContext) {
        public_freeze_object(new(package::claim(otw, ctx), ctx));
    }

    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>Say that want to create a wrapper type <code>Wrapper&lt;T&gt;</code> which allows other types to instantiate it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module examples::export_display {
    use std::string;
    use sui::display::{Self, Display};
    use sui::object::{Self, UID};
    use sui::tx_context::TxContext;
    use ob_permissions::frozen_publisher::{Self, FrozenPublisher};
    use ob_permissions::witness::{Witness as DelegatedWitness};

    struct Witness has drop {}

    struct Wrapper&lt;T: key + store&gt; has key, store {
        id: UID,
        inner: T
    }

    public fun new&lt;T: key + store&gt;(inner: T, ctx: &amp;mut TxContext): Wrapper&lt;T&gt; {
        Wrapper { id: object::new(ctx), inner }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We can then add a function that lets the inner type witnesses export their inner display:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module examples::export_display {
    // ...

    // === Display standard ===

    /// Creates a new `Display` with some default settings.
    public fun new_display&lt;T: key + store&gt;(
        _witness: DelegatedWitness&lt;T&gt;,
        pub: &amp;FrozenPublisher,
        ctx: &amp;mut TxContext,
    ): Display&lt;Wrapper&lt;T&gt;&gt; {
        let display =
            frozen_publisher::new_display&lt;Witness, Wrapper&lt;T&gt;&gt;(Witness {}, pub, ctx);

        display::add(&amp;mut display, string::utf8(b&quot;type&quot;), string::utf8(b&quot;Wrapper&quot;));

        display
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We can then create a <code>FrozenPublisher</code> and freeze it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module examples::export_display {
    fun init(otw: TEST_WRAPPED_DISPLAY, ctx: &amp;mut TxContext) {
        // ...

        frozen_publisher::freeze_from_otw(otw, ctx(&amp;mut scenario));

        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This allows others developers that come along and create their inner types <code>T</code> and create their display for <code>Wrapper&lt;T&gt;</code> as shown in the test code below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test_only]
module examples::test_wrapped_display {
    use std::string::utf8;
    use sui::object::UID;
    use sui::transfer;
    use sui::display;
    use sui::test_scenario::{Self, ctx};
    use ob_permissions::frozen_publisher::{Self, FrozenPublisher};
    use ob_permissions::witness;

    use examples::export_display;

    // One Time Witness
    struct TEST_WRAPPED_DISPLAY has drop {}

    // Witness for authentication
    struct Witness has drop {}

    struct InnerType has key, store {
        id: UID,
    }

    const WRAPPER_PUBLISHER_ADDR: address = @0x1;
    const INNER_PUBLISHER_ADDR: address = @0x2;

    #[test]
    fun create_wrapped_display() {
        let scenario = test_scenario::begin(WRAPPER_PUBLISHER_ADDR);

        frozen_publisher::freeze_from_otw(TEST_WRAPPED_DISPLAY {}, ctx(&amp;mut scenario));

        test_scenario::next_tx(&amp;mut scenario, INNER_PUBLISHER_ADDR);

        let dw = witness::from_witness&lt;InnerType, Witness&gt;(Witness {});
        
        let frozen_pub = test_scenario::take_immutable&lt;FrozenPublisher&gt;(&amp;scenario);

        let inner_display = export_display::new_display(dw, &amp;frozen_pub, ctx(&amp;mut scenario));

        display::add(&amp;mut inner_display, utf8(b&quot;name&quot;), utf8(b&quot;InnerType&quot;));
        display::add(&amp;mut inner_display, utf8(b&quot;description&quot;), utf8(b&quot;This is the inner display for Wrapper&lt;InnerType&gt;&quot;));

        transfer::public_transfer(inner_display, INNER_PUBLISHER_ADDR);

        test_scenario::return_immutable(frozen_pub);
        test_scenario::end(scenario);
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Associated readings:</p>
<ul>
<li><a href="https://docs.sui.io/concepts/dynamic-fields">Sui Docs: Dynamic Fields</a></li>
<li><a href="https://github.com/nmboavida/suinami-book/blob/main/examples/sources/transferable_dfs.move">Examples: Transferable DFs</a></li>
</ul>
<h1 id="transferable-dynamic-fields"><a class="header" href="#transferable-dynamic-fields">Transferable Dynamic-Fields</a></h1>
<blockquote>
<p>In the Sui blockchain, dynamic fields are a flexible feature allowing users to add, modify, or remove fields from blockchain objects on-the-fly.</p>
<p>These fields can be named arbitrarily and can store heterogeneous values, offering more versatility compared to fixed fields defined at the time of module publication. There are two types: 'fields' that can store any value but make wrapped objects inaccessible by external tools, and 'object fields' that must store objects but remain accessible by their ID.</p>
</blockquote>
<p>One challenge that dynamic fields introduce is that when we attach dynamic fields to an object UID, if for any reason we want to burn the underlying object and move the dynamic fields to another object, we would have to perform <code>2n</code> amount of <code>remove</code> and <code>add</code> operations, where <code>n</code> is the number of dynamic fields.</p>
<p>This becomes especially hard if the dynamic fields are protected with key objects from a myriad of different packages. In words it pretty much becomes impossible to move the fields in a single programmable transaction and puts a big strain on the client side to build such transactions as the client would have to know upfront all the packages it needs to interact with.</p>
<p>To fix for this challenge, we introduce transferable dynamic fields by allocating the dynamic fields not to the field <code>id: UID</code> of the object but to a special field of its own:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module examples::transferable_dfs {
    use sui::tx_context::TxContext;
    use sui::object::{Self, UID};

    struct MyObject {
        id: UID,

        // .. other fields

        /// We use this UID instead to store the dynamic fields
        dfs: UID
    }

    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>In Sui Move, we cannot transfer the <code>id: UID</code> to another object, as this is forbidden. Nonetheless, we can transfer <code>UID</code> that are not themselves the <code>id</code> field of the object. We can therefore have a <code>burn</code> function that looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module examples::transferable_dfs {
    use sui::tx_context::TxContext;
    use sui::object::{Self, UID};

    // ..

    // This function is just for illustration. In a real-world scenario
    // it would most likely have permissions around it.
    public fun burn(
        obj: MyObject,
    ): UID {
        let MyObject { id, dfs } = obj;

        object::delete(id);

        dfs
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We would then be able to move the dynamic fields to the new object.</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="patterns/05_transferable_dfs.html">Suinamic Book: Transferable DFs</a></li>
<li><a href="https://github.com/nmboavida/suinami-book/blob/main/examples/sources/map_reduce.move">Examples: Map-Reduce</a></li>
</ul>
<h1 id="map-reduce"><a class="header" href="#map-reduce">Map-Reduce</a></h1>
<p>Map Reduce is a pattern inspired in a Big Data pattern initially developed by the Hadoop framework and is a programming model that processes large data sets by dividing the work into two phases: the Map phase, which applies operations on individual or chunks of data, and the Reduce phase, which performs a final aggregation operation.</p>
<p>But how does this relate to Sui?</p>
<p>In Sui, operations on Single Writer Objects are fully parallelizable whereas operations on Shared Objects need to go through full consensus. With the Sui Map-Reduce pattern we can levage SWO transactions to add tens if not hundreds of thousands of objects to a Shared Object whilst having most transactions being parallelized. We do this by leveraging the Transferable Dynamic Fields pattern discussed previously.</p>
<p>Lets start with an example of two objects that represent the same abstraction, though one is private and the other one is shared:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module examples::map_reduce {
    use std::vector;
    use sui::tx_context::{Self, TxContext};
    use sui::object::{Self, UID};
    use sui::transfer;
    use sui::dynamic_object_field as dof;

    /// `PrivateWarehouse` object which stores Digital Assets
    struct PrivateWarehouse&lt;phantom T&gt; has key, store {
        /// `Warehouse` ID
        id: UID,
        total_deposited: u64,
        warehouse: UID,
    }

    /// `SharedWarehouse` object which stores Digital Assets
    struct SharedWarehouse&lt;phantom T&gt; has key, store {
        /// `Warehouse` ID
        id: UID,
        total_deposited: u64,
        warehouse: vector&lt;UID&gt;,
    }

    /// Creates a `PrivateWarehouse` and transfers to transaction sender
    public entry fun new_private&lt;T: key + store&gt;(
        ctx: &amp;mut TxContext
    ) {
        let warehouse = PrivateWarehouse&lt;T&gt; {
            id: object::new(ctx),
            total_deposited: 0,
            warehouse: object::new(ctx),
        };

        transfer::transfer(warehouse, tx_context::sender(ctx));
    }

    /// Adds NFTs to `PrivateWarehouse` in bulk
    public entry fun add_nfts&lt;T: key + store&gt;(
        warehouse: &amp;mut PrivateWarehouse&lt;T&gt;,
        nfts: vector&lt;T&gt;,
    ) {
        let len = vector::length(&amp;nfts);
        let i = 0;

        while (len &gt; 0) {
            let nft = vector::pop_back(&amp;mut nfts);
            dof::add(&amp;mut warehouse.warehouse, i, nft);

            len = len - 1;
            i = i + 1;
        };

        vector::destroy_empty(nfts);
    }

    /// Burns `PrivateWarehouse`s in builk, moves NFTs to `SharedWarehouse`
    public fun share_warehouse&lt;T: key + store&gt;(
        warehouses: vector&lt;PrivateWarehouse&lt;T&gt;&gt;,
        ctx: &amp;mut TxContext
    ) {
        let shared_warehouse = SharedWarehouse&lt;T&gt; {
            id: object::new(ctx),
            total_deposited: 0,
            warehouse: vector::empty(),
        };

        let len = vector::length(&amp;warehouses);
        let i = 0;

        while (len &gt; 0) {
            let wh = vector::pop_back(&amp;mut warehouses);
            let PrivateWarehouse { id, total_deposited: new_deposit, warehouse: wh_ } = wh;

            object::delete(id);
            shared_warehouse.total_deposited = shared_warehouse.total_deposited + new_deposit;
            vector::push_back(&amp;mut shared_warehouse.warehouse, wh_);

            len = len - 1;
            i = i + 1;
        };

        vector::destroy_empty(warehouses);
        transfer::share_object(shared_warehouse);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We can now instantiate SWO warehouses in parallel calling <code>new_private</code>, add any non-fungible asset in parallel by calling <code>add_nfts</code>. This is the &quot;Map&quot; part in the &quot;Map-Reduce&quot;. We then call <code>share_warehouse</code> which will burn all individual private warehouses, and aggregate all its NFTs into a shared warehouse.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-data-structures"><a class="header" href="#advanced-data-structures">Advanced Data Structures</a></h1>
<p>A list of advanced data structures in Sui Move:</p>
<ul>
<li><a href="data_structures/01_dynamic_vec.html">Dynamic Vectors</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>Associated readings:</p>
<ul>
<li><a href="https://docs.sui.io/concepts/dynamic-fields">Sui Docs: Dynamic Fields</a></li>
<li><a href="https://github.com/Origin-Byte/nft-protocol/blob/main/contracts/utils/sources/dynamic_vec.move">OriginByte Utils: Dynamic Vector</a></li>
</ul>
<h1 id="dynamic-vectors"><a class="header" href="#dynamic-vectors">Dynamic Vectors</a></h1>
<p>In the Sui blockchain, dynamic fields are a flexible feature allowing users to add, modify, or remove fields from blockchain objects on-the-fly.</p>
<p>These fields can be named arbitrarily and can store heterogeneous values, offering more versatility compared to fixed fields defined at the time of module publication. There are two types: 'fields' that can store any value but make wrapped objects inaccessible by external tools, and 'object fields' that must store objects but remain accessible by their ID.</p>
<p>Dynamic fields are great because they serve as an abstraction for unbounded object scalability and extendibility. An example of scalability is the object type <code>TableVec</code> which allows us to create an arbitrarily long vector.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TableVec&lt;phantom Element: store&gt; has store {
    /// The contents of the table vector.
    contents: Table&lt;u64, Element&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="runtime-hit"><a class="header" href="#runtime-hit">Runtime hit</a></h2>
<p>One trade-off when using dynamic fields to scale your objects in size is that your application will suffer a runtime hit. This is fine for most cases, but for perfomance critical applications you can use a dynamic vector from the OriginByte library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DynVec&lt;Element&gt; has store {
    vec_0: vector&lt;Element&gt;,
    vecs: UID,
    current_chunk: u64,
    tip_length: u64,
    total_length: u64,
    limit: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>This abstraction combines the best of both worlds, the runtime performance of static fields, and the scalability of dynamic fields. In a nutshell, <code>DynVec</code> loads the tip of the entire vector into a static field vector, allowing <code>push_back</code> and <code>pop_back</code> operations to be more perfomant. When popping an element from the vector, when the the sub-vector tip gets exhausted we load the next chunk to the static vector.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>public fun pop_back&lt;Element: store&gt;(
    v: &amp;mut DynVec&lt;Element&gt;,
): Element {
    // This only occurs when it has no elements
    assert!(v.tip_length != 0, 0);

    let elem = if (v.tip_length == 1) {
        remove_chunk(v)
    } else {
        pop_element_from_chunk(v)
    };

    elem
}
<span class="boring">}</span></code></pre></pre>
<p>Conversely, when we push elements to the back of the vector, when the sub-vector tip gets full, we move it to a dynamic field and instantiate a new static vector.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>public fun push_back&lt;Element: store&gt;(
    v: &amp;mut DynVec&lt;Element&gt;,
    elem: Element,
) {
    // If the tip is maxed out, create a new vector and add it there
    if (v.tip_length == v.limit) {
        insert_chunk(v, elem);
    } else {
        push_element_to_chunk(v, elem);
    };
}
<span class="boring">}</span></code></pre></pre>
<p>To create a dynamic vector you can simply call the <code>empty</code> constructor function and passing a limit which defines the capacity of each vector chunk.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Create an empty dynamic vector.
public fun empty&lt;Element: store&gt;(limit: u64, ctx: &amp;mut TxContext): DynVec&lt;Element&gt; {
    DynVec {
        vec_0: vector::empty(),
        vecs: object::new(ctx),
        current_chunk: 0,
        tip_length: 0,
        total_length: 0,
        limit,
    }
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
